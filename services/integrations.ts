import { ApiConfig, ExecutionResults } from '../types';

/**
 * Backend Service Layer
 * Handles direct HTTP communication with external APIs.
 */

// --- GitHub ---
export const fetchGitHubCommit = async (config: ApiConfig) => {
  if (!config.githubOwner || !config.githubRepo || !config.githubToken) {
    throw new Error("Missing GitHub configuration");
  }

  const response = await fetch(`https://api.github.com/repos/${config.githubOwner}/${config.githubRepo}/commits?per_page=1`, {
    headers: {
      'Authorization': `token ${config.githubToken}`,
      'Accept': 'application/vnd.github.v3+json'
    }
  });

  if (!response.ok) {
    throw new Error(`GitHub API Error: ${response.status} ${response.statusText}`);
  }

  return await response.json();
};

// --- Slack ---
export const sendSlackNotification = async (config: ApiConfig, message: string) => {
  if (!config.slackWebhook) {
    throw new Error("Missing Slack Webhook URL");
  }

  // Using no-cors mode because Slack webhooks don't return CORS headers for browser fetch.
  // This means we can't read the response, but the request is sent.
  await fetch(config.slackWebhook, {
    method: 'POST',
    mode: 'no-cors',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ text: message })
  });

  return true;
};

// --- Gmail (Simulation) ---
export const sendEmail = async (config: ApiConfig, recipient: string, subject: string, body: string) => {
  // Simulate network delay
  await new Promise(resolve => setTimeout(resolve, 800));

  // In a real app, this would use the Gmail API via a backend proxy or Google Identity Services
  // For this demo, we simulate success if a sender address is configured.
  
  if (!config.gmailAddress) {
    throw new Error("Missing Gmail Sender Address configuration");
  }

  console.log(`[Gmail Simulation] Sending to ${recipient} from ${config.gmailAddress}`);
  console.log(`Subject: ${subject}`);
  console.log(`Body: ${body}`);

  return { 
    id: `msg-${Date.now()}`, 
    threadId: `th-${Date.now()}` 
  };
};

// --- Jira ---
export const createJiraTicket = async (config: ApiConfig, results: ExecutionResults) => {
  if (!config.jiraDomain || !config.jiraEmail || !config.jiraToken || !config.jiraProjectKey) {
    throw new Error("Missing Jira configuration");
  }

  // Construct Basic Auth Header
  const auth = btoa(`${config.jiraEmail}:${config.jiraToken}`);

  const bodyData = {
    fields: {
      project: {
        key: config.jiraProjectKey
      },
      summary: `[${results.detectedComponent}] ${results.bugSummary}`,
      description: {
        type: "doc",
        version: 1,
        content: [
          {
            type: "paragraph",
            content: [
              {
                type: "text",
                text: `Auto-generated by Konnect-Ai Agent.\n\nPriority: ${results.bugPriority}\nDetected in Component: ${results.detectedComponent}\n\nRelated Commit: ${results.commitHash}`
              }
            ]
          }
        ]
      },
      issuetype: {
        name: "Bug"
      }
    }
  };

  const response = await fetch(`${config.jiraDomain}/rest/api/3/issue`, {
    method: 'POST',
    headers: {
      'Authorization': `Basic ${auth}`,
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(bodyData)
  });

  if (!response.ok) {
    // Attempt to read error body
    let errorMsg = `${response.status} ${response.statusText}`;
    try {
      const errBody = await response.json();
      errorMsg += ` - ${JSON.stringify(errBody)}`;
    } catch (e) { /* ignore */ }
    
    throw new Error(`Jira API Error: ${errorMsg}`);
  }

  return await response.json();
};